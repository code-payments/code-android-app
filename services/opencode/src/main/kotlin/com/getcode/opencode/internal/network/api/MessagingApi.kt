package com.getcode.opencode.internal.network.api

import com.codeinc.opencode.gen.messaging.v1.MessagingGrpc
import com.codeinc.opencode.gen.messaging.v1.MessagingService
import com.getcode.ed25519.Ed25519.KeyPair
import com.getcode.opencode.internal.annotations.OpenCodeManagedChannel
import com.getcode.opencode.internal.network.core.GrpcApi
import com.getcode.opencode.internal.network.extensions.asRendezvousKey
import com.getcode.opencode.internal.network.extensions.sign
import com.getcode.opencode.internal.network.extensions.asMessageId
import com.getcode.opencode.internal.network.extensions.asProtobufMessage
import com.getcode.opencode.model.core.ID
import com.getcode.opencode.model.messaging.Message
import io.grpc.ManagedChannel
import io.grpc.stub.StreamObserver
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flowOn
import javax.inject.Inject

internal class MessagingApi @Inject constructor(
    @OpenCodeManagedChannel
    managedChannel: ManagedChannel,
): GrpcApi(managedChannel) {

    private val api = MessagingGrpc.newStub(managedChannel).withWaitForReady()

    /**
     * Opens a stream of messages. Messages are routed using the public key of a rendezvous keypair
     * derived by both the sender and the recipient of the messages. The sender may be a client or server.
     *
     * <p>
     *
     * Messages are expected to be acked once they have been processed by the client. Ack'd messages
     * will no longer be delivered on future OpenMessageStream calls, and are eligible for deletion
     * from the service. Clients should, however, handle duplicate delivery of messages.
     *
     * <p>
     *
     * For grabbing a bill, the expected flow is as follows:
     *
     * 1. The payment sender creates a cash scan code
     * 2. The payment sender calls OpenMessageStream on the rendezvous public key, which is
     * derived by using sha256(scan payload) as the keypair seed.
     * 3. The payment recipient scans the code and uses SendMessage to send their account ID
     * back to the sender via the rendezvous public key.
     * 4. The payment sender receives the message, submits the intent, and closes the stream.
     *
     * <p>
     *
     * For receiving a bill of requested value, the expected flow is as follows:
     *
     * 1. The payment recipient uses SendMessage to send their account ID and payment amount to
     * the sender via the rendezvous public key, which is derived by using sha256(scan payload)
     * as the keypair seed.
     * 2. The payment recipient calls OpenMessageStream on the rendezvous public key to listen
     * for status messages generated by client/server. It must ignore the original message it sent
     * as part of step 1.
     * 3. The payment recipient creates a payment request scan code
     * 4. The payment sender calls PollMessages on the rendezvous public key. This is ok because
     * we know the message exists per step 1, and doesn't actually incur a long poll. This is a
     * required hack because we don't have the infrastructure in place to allow multiple listens
     * on the same stream, and the recipient needs real-time status updates.
     * 5. The payment sender receives the message (any status messages are ignored), and submits the
     * intent.
     * 6. The payment recipient observes status message (eg. IntentSubmitted, ClientRejectedPayment,
     * WebhookCalled) for payment state.
     * 7. The payment recipient closes the stream once the payment hits a terminal state, or times out.
     *
     */
    fun openMessageStream(
        rendezvous: KeyPair
    ): Flow<MessagingService.OpenMessageStreamResponse> {
        val request = MessagingService.OpenMessageStreamRequest.newBuilder()
            .setRendezvousKey(rendezvous.asRendezvousKey())
            .apply { setSignature(sign(rendezvous)) }
            .build()

        return api::openMessageStream
            .callAsCancellableFlow(request)
            .flowOn(Dispatchers.IO)
    }

    /**
     * Opens a message stream with a ping/pong keepalive mechanism to monitor the health of the stream
     * at both client and server ends. This is an enhanced version of OpenMessageStream.
     *
     * <p>
     *
     * The keepalive protocol operates as follows:
     *
     * 1. Client initiates a stream by sending an OpenMessageStreamRequest.
     * 2. Upon stream initialization, server begins the keepalive protocol.
     * 3. Server sends a ping to the client.
     * 4. Client responds with a pong as quickly as possible, noting the delay to anticipate
     * the next ping.
     * 5. Steps 3 and 4 repeat until the stream is explicitly terminated or deemed unhealthy.
     *
     * <p>
     *
     * Client considerations:
     * - Client should process messages asynchronously to ensure ping responses are not delayed.
     * - Clients should implement a reasonable backoff strategy for repeated timeout failures.
     * - Clients abusing pong messages may have their streams terminated by the server.
     *
     * <p>
     *
     * The server will deliver messages in real-time as they are observed throughout the stream's
     * lifetime. Messages sent over the stream should not impact the timing of the ping/pong protocol.
     * Payment flow protocols remain identical to those documented in OpenMessageStream.
     *
     * <p>
     *
     * > NOTE: This API requires OpenMessageStreamRequest.signature to be set as part of the
     * migration to this updated protocol.
     *
     * @see openMessageStream
     */
    fun openMessageStreamWithKeepAlive(
        observer: StreamObserver<MessagingService.OpenMessageStreamWithKeepAliveResponse>
    ): StreamObserver<MessagingService.OpenMessageStreamWithKeepAliveRequest> {
        return api.openMessageStreamWithKeepAlive(observer)
    }

    /**
     * Retrieves messages using a polling mechanism instead of a real-time stream like
     * OpenMessageStream. Message updates are not delivered in real-time and depend on the
     * polling interval. This RPC supports all message types.
     * <p>
     * <b>Note:</b> This is a temporary RPC implementation until OpenMessageStream can be
     * enhanced to support generic usage across both client and server, including features
     * such as multiple listeners.
     *
     * @see openMessageStream
     */
    fun pollMessages(
        rendezvous: KeyPair
    ): Flow<MessagingService.PollMessagesResponse> {
        val request = MessagingService.PollMessagesRequest.newBuilder()
            .setRendezvousKey(rendezvous.asRendezvousKey())
            .apply { setSignature(sign(rendezvous)) }
            .build()

        return api::pollMessages
            .callAsCancellableFlow(request)
            .flowOn(Dispatchers.IO)
    }

    /**
     * Acks one or more messages that have been successfully delivered to the client.
     */
    fun ackMessages(
        rendezvous: KeyPair,
        messageIds: List<ID> = emptyList()
    ): Flow<MessagingService.AckMesssagesResponse> {
        val request = MessagingService.AckMessagesRequest.newBuilder()
            .setRendezvousKey(rendezvous.asRendezvousKey())
            .apply {
               messageIds.forEachIndexed { index, id ->
                   setMessageIds(index, id.asMessageId())
               }
            }.build()

        return api::ackMessages
            .callAsCancellableFlow(request)
            .flowOn(Dispatchers.IO)
    }

    /**
     * Sends a message
     */
    fun sendMessage(
        message: Message,
        rendezvous: KeyPair,
    ): Flow<MessagingService.SendMessageResponse> {
        val request = MessagingService.SendMessageRequest.newBuilder()
            .setMessage(message.asProtobufMessage())
            .setRendezvousKey(rendezvous.asRendezvousKey())
            .apply { setSignature(sign(rendezvous)) }
            .build()

        return api::sendMessage
            .callAsCancellableFlow(request)
            .flowOn(Dispatchers.IO)
    }
}