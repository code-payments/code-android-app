syntax = "proto3";
package flipchat.chat.v1;
option go_package = "github.com/code-payments/flipchat-protobuf-api/generated/go/chat/v1;chatpb";
option java_package = "com.codeinc.flipchat.gen.chat.v1";
option objc_class_prefix = "FCPBChatV1";
import "common/v1/flipchat.proto";
import "messaging/v1/model.proto";
import "google/protobuf/timestamp.proto";

service Chat {
    // StreamChatEvents streams all chat events for the requesting user.
    //
    // Chat events will include any update to a chat, including:
    //   1. Metadata changes.
    //   2. Membership changes.
    //   3. Latest messages.
    //
    // The server will optionally filter out some events depending on load
    // and chat type. For example, Broadcast chats will not receive latest
    // messages.
    //
    // Clients should use GetMessages to backfill in any historical messages
    // for a chat. It should be sufficient to rely on ChatEvents for some types
    // of chats, but using StreamMessages provides a guarentee of message events
    // for all chats.
    rpc StreamChatEvents(stream StreamChatEventsRequest) returns (stream StreamChatEventsResponse);
    // GetChats gets the set of chats for an owner account using a paged API.
    // This RPC is aware of all identities tied to the owner account.
    rpc GetChats(GetChatsRequest) returns (GetChatsResponse);
    // GetChat returns the metadata for a specific chat.
    rpc GetChat(GetChatRequest) returns (GetChatResponse);
    // StartChat starts a chat. The RPC call is idempotent and will use existing
    // chats whenever applicable within the context of message routing.
    rpc StartChat(StartChatRequest) returns (StartChatResponse);
    // JoinChat joins a given chat.
    rpc JoinChat(JoinChatRequest) returns (JoinChatResponse);
    // LeaveChat leaves a given chat.
    rpc LeaveChat(LeaveChatRequest) returns (LeaveChatResponse);
    // SetCoverCharge sets a chat's cover charge
    rpc SetCoverCharge(SetCoverChargeRequest) returns (SetCoverChargeResponse);
    // RemoveUser removes a user from a chat
    rpc RemoveUser(RemoveUserRequest) returns (RemoveUserResponse);
    // MuteUser mutes a user in the chat and removes their ability to send messages
    rpc MuteUser(MuteUserRequest) returns (MuteUserResponse);
    // MuteChat mutes a chat and disables push notifications
    rpc MuteChat(MuteChatRequest) returns (MuteChatResponse);
    // UnmuteChat unmutes a chat and enables push notifications
    rpc UnmuteChat(UnmuteChatRequest) returns (UnmuteChatResponse);
    // ReportUser reports a user for a given message
    //
    // todo: might belong in a different service long-term
    rpc ReportUser(ReportUserRequest) returns (ReportUserResponse);
}
message StreamChatEventsRequest {
    oneof type {
        Params params = 1;
        common.v1.ClientPong pong = 2;
    }
    message Params {
        common.v1.Auth auth = 1;
        // ts contains the time for stream open.
        //
        // It is used primarily as a nonce for auth. Server may reject
        // timestamps that are too far in the future or past.
        google.protobuf.Timestamp ts = 2;
    }
}
message StreamChatEventsResponse {
    oneof type {
        common.v1.ServerPing ping = 1;
        StreamError error = 2;
        EventBatch events = 3;
    }
    message StreamError {
        Code code = 1;
        enum Code {
            DENIED = 0;
        }
    }
    message EventBatch {
        repeated ChatUpdate updates = 1 ;
    }
    // ChatUpdate contains a set of updates for a given chat id.
    //
    // Only the relevant fields will be set on update. On initial
    // stream open, all fields will be set, however.
    message ChatUpdate {
        common.v1.ChatId chat_id = 1;
        // metadata contains the latest (full) metadata of the chat.
        Metadata metadata = 2;
        // MemberUpdate contains an update to the membership set.
        MemberUpdate member_update = 3;
        // Message contains the last known message of the chat.
        messaging.v1.Message last_message = 4;
        // where 'relevant' means "relevant to UI updates". For example,
        // when a user has read the latest message.
        PointerUpdate pointer = 5;
        message PointerUpdate {
            common.v1.UserId member = 1;
            messaging.v1.Pointer pointer = 2;
        }
        // IsTyping indicates whether or not someone is typing in the group.
        messaging.v1.IsTyping is_typing = 6;
    }
    message MemberUpdate {
        oneof kind {
            Refresh refresh = 1;
            // May want to add Joined and Removed events.
            // However, these may make more sense as a message, rather than
            // an out of band event.
        }
        message Refresh {
            repeated Member members = 1 ;
        }
    }
}
message GetChatsRequest {
    common.v1.QueryOptions query_options = 1;
    common.v1.Auth auth = 2;
}
message GetChatsResponse {
    Result result = 1;
    enum Result {
        OK = 0;
    }
    repeated Metadata chats = 2 ;
}
message GetChatRequest {
    oneof identifier {
        common.v1.ChatId chat_id = 1;
        uint64 room_number = 2;
    }
    // Auth is an optional field that authenticates the call, which
    // can be used to fill out extra information in the Metadata.
    common.v1.Auth auth = 10;
}
message GetChatResponse {
    Result result = 1;
    enum Result {
        OK        = 0;
        NOT_FOUND = 1;
    }
    // Metadata is the chat metadata, if result == OK.
    //
    // The contents of the metadata may change whether or not the
    // call was authenticated.
    Metadata metadata = 2;
    // Members contains the chat members, if result == OK.
    repeated Member members = 3;
}
message StartChatRequest {
    oneof parameters {
        StartTwoWayChatParameters two_way_chat = 1;
        StartGroupChatParameters group_chat = 2;
    }
    // StartTwoWayChatParameters contains the parameters required to start
    // or recover a two way chat between the caller and the specified 'other_user'.
    //
    // The 'other_user' is currently the 'tip_address', normally retrieved from
    // user.Identity.GetTwitterUser(username).
    message StartTwoWayChatParameters {
        // The account id of the user the caller wishes to chat with.
        common.v1.UserId other_user_id = 1;
    }
    message StartGroupChatParameters {
        // A set of users (not including self) to initially set in the group chat.
        repeated common.v1.UserId users = 1 ;
        // Optional title to set for the group.
        string title = 2;
        // Optional payment for creating the group. It's up to server to decide
        // if the user is allowed to create a group without payment.
        common.v1.IntentId payment_intent = 3;
    }
    common.v1.Auth auth = 10;
}
message StartChatResponse {
    Result result = 1;
    enum Result {
        OK = 0;
        // DENIED indicates the caller is not allowed to start/join the chat.
        DENIED = 1;
        // USER_NOT_FOUND indicates that (one of) the target user's was not found.
        USER_NOT_FOUND = 2;
    }
    // The chat to use, if result == OK.
    Metadata chat = 2;
    // Members contains the chat members, if result == OK.
    repeated Member members = 3;
}
message StartGroupChatPaymentMetadata {
    // The user creating the group chat, who will be the initial owner
    common.v1.UserId user_id = 1;
}
message JoinChatRequest {
    oneof identifier {
        common.v1.ChatId chat_id = 1;
        uint64 room_id = 2;
    }
    // Does the user want to join without the ability to send messages in the chat?
    // If so, then payment_intent is not required? Otherwise, it is.
    bool without_send_permission = 8;
    // The payment for joining a chat, which is required for sending messages in
    // the chat.
    //
    // Note: The chat owner can always bypass payment.
    common.v1.IntentId payment_intent = 9;
    common.v1.Auth auth = 10;
}
message JoinChatResponse {
    Result result = 1;
    enum Result {
        OK = 0;
        DENIED = 1;
    }
    // The chat metadata, if join was successful.
    Metadata metadata = 2;
    // The members of the chat, if join was successful.
    repeated Member members = 3;
}
message JoinChatPaymentMetadata {
    // The user joining the chat
    common.v1.UserId user_id = 1;
    // The chat that the user is joining
    common.v1.ChatId chat_id = 2;
}
message LeaveChatRequest {
    common.v1.ChatId chat_id = 1;
    common.v1.Auth auth = 2;
}
message LeaveChatResponse {
    Result result = 1;
    enum Result {
        OK = 0;
    }
}
message SetCoverChargeRequest {
    common.v1.ChatId chat_id = 1;
    common.v1.PaymentAmount cover_charge = 2;
    common.v1.Auth auth = 3;
}
message SetCoverChargeResponse {
    Result result = 1;
    enum Result {
        OK       = 0;
        DENIED   = 1;
        CANT_SET = 2;
    }
}
message RemoveUserRequest{
    common.v1.ChatId chat_id = 1;
    common.v1.UserId user_id = 2;
    common.v1.Auth auth = 3;
}
message RemoveUserResponse{
    Result result = 1;
    enum Result {
        OK       = 0;
        DENIED   = 1;
    }
}
message MuteUserRequest{
    common.v1.ChatId chat_id = 1;
    common.v1.UserId user_id = 2;
    common.v1.Auth auth = 3;
}
message MuteUserResponse{
    Result result = 1;
    enum Result {
        OK       = 0;
        DENIED   = 1;
    }
}
message MuteChatRequest {
    common.v1.ChatId chat_id = 1;
    common.v1.Auth auth = 2;
}
message MuteChatResponse {
    Result result = 1;
    enum Result {
        OK       = 0;
        DENIED   = 1;
    }
}
message UnmuteChatRequest {
    common.v1.ChatId chat_id = 1;
    common.v1.Auth auth = 2;
}
message UnmuteChatResponse {
    Result result = 1;
    enum Result {
        OK       = 0;
        DENIED   = 1;
    }
}
message ReportUserRequest{
    common.v1.UserId user_id = 1;
    messaging.v1.MessageId message_id = 2;
    common.v1.Auth auth = 3;
}
message ReportUserResponse{
    Result result = 1;
    enum Result {
        OK       = 0;
    }
}
message Metadata {
    common.v1.ChatId chat_id = 1;
    // The type of chat
    ChatType type = 2 ;
    enum ChatType {
        UNKNOWN = 0;
        TWO_WAY = 1;
        GROUP   = 2;
    }
    // The chat title, which is _only_ set by server if an explicit title
    // was set. Otherwise, clients should fill in an appropriate chat title.
    string title = 3 ;
    // If non-zero, the room number associated with the chat.
    uint64 room_number = 4;
    // Are push notifications enabled for this chat (from the perspective of the caller)?
    bool is_push_enabled = 5;
    // Can the user disable push notifications for this chat using MuteChat?
    bool can_disable_push = 6;
    // Number of (estimated) unread message (from the perspective of the caller).
    uint32 num_unread = 7;
    // Owner is the owner/creator of the chat.
    //
    // This is a super priviledge role, in which there can only be one.
    // This role is displayed as a 'host' currently.
    common.v1.UserId owner = 8;
    // If present, the cover charge that must be paid to join the chat
    common.v1.PaymentAmount cover_charge = 9;
    // The timestamp of the last activity in this chat
    google.protobuf.Timestamp last_activity = 10;
    // If there are more unread messages than indicated by num_unread. If this is
    // true, client should show num_unread+ as the unread count.
    bool has_more_unread = 11;
}
message Member {
    common.v1.UserId user_id = 1;
    // The chat member's identity/profile information.
    //
    // It is a light weight version of the users full profile, which
    // can be retrieved from the Profile service.
    MemberIdentity identity = 2;
    // Chat message state for this member.
    //
    // If set, the list may contain DELIVERED and READ pointers. SENT pointers
    // are only shared between the sender and server, to indicate persistence.
    //
    // The server may wish to omit all pointers in various types of group chats
    // or as relief valves.
    repeated messaging.v1.Pointer pointers = 3 ;
    // If the member is the caller (where applicable), will be set to true.
    bool is_self = 4;
    // Does the chat member have permission to perform moderation actions in
    // the chat?
    bool has_moderator_permission = 5;
    // Has the chat member been muted by a moderator? If so, they cannot send
    // messages, even if they paid for the permission.
    bool is_muted = 6;
    // Does the chat member have permission to send messages in the chat? If
    // not, the user is considered to be a spectator.
    bool has_send_permission = 7;
}
message MemberIdentity {
    // If present, the display name of the user.
    string display_name = 1 ;
    // If present, the URL of the users profile pic.
    string profile_pic_url = 2 ;
}
