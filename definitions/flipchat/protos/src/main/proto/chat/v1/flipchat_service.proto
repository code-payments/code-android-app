syntax = "proto3";
package flipchat.chat.v1;
option go_package = "github.com/code-payments/flipchat-protobuf-api/generated/go/chat/v1;chatpb";
option java_package = "com.codeinc.flipchat.gen.chat.v1";
option objc_class_prefix = "FCPBChatV1";
import "common/v1/flipchat.proto";
import "messaging/v1/model.proto";

service Chat {
    // StreamChatEvents streams all chat events for the requesting user.
    //
    // Chat events will include any update to a chat, including:
    //   1. Metadata changes.
    //   2. Membership changes.
    //   3. Latest messages.
    //
    // The server will optionally filter out some events depending on load
    // and chat type. For example, Broadcast chats will not receive latest
    // messages.
    //
    // Clients should use GetMessages to backfill in any historical messages
    // for a chat. It should be sufficient to rely on ChatEvents for some types
    // of chats, but using StreamMessages provides a guarentee of message events
    // for all chats.
    rpc StreamChatEvents(stream StreamChatEventsRequest) returns (stream StreamChatEventsResponse);
    // GetChats gets the set of chats for an owner account using a paged API.
    // This RPC is aware of all identities tied to the owner account.
    rpc GetChats(GetChatsRequest) returns (GetChatsResponse);
    // GetChat returns the metadata for a specific chat.
    rpc GetChat(GetChatRequest) returns (GetChatResponse);
    // StartChat starts a chat. The RPC call is idempotent and will use existing
    // chats whenever applicable within the context of message routing.
    rpc StartChat(StartChatRequest) returns (StartChatResponse);
    // JoinChat joins a given chat.
    rpc JoinChat(JoinChatRequest) returns (JoinChatResponse);
    // LeaveChat leaves a given chat.
    rpc LeaveChat(LeaveChatRequest) returns (LeaveChatResponse);
    // SetMuteState configures a chat member's mute state.
    rpc SetMuteState(SetMuteStateRequest) returns (SetMuteStateResponse);
}
message StreamChatEventsRequest {
    oneof type {
        Params params = 1;
        common.v1.ClientPong pong = 2;
    }
    message Params {
        common.v1.Auth auth = 1;
    }
}
message StreamChatEventsResponse {
    oneof type {
        common.v1.ServerPing ping = 1;
        StreamError error = 2;
        EventBatch events = 3;
    }
    message StreamError {
        Code code = 1;
        enum Code {
            DENIED = 0;
        }
    }
    message EventBatch {
        repeated ChatUpdate updates = 1 ;
    }
    // ChatUpdate contains a set of updates for a given chat id.
    //
    // Only the relevant fields will be set on update. On initial
    // stream open, all fields will be set, however.
    message ChatUpdate {
        common.v1.ChatId chat_id = 1;
        // metadata contains the latest (full) metadata of the chat.
        Metadata metadata = 2;
        // MemberUpdate contains an update to the membership set.
        MemberUpdate member_update = 3;
        // Message contains the last known message of the chat.
        messaging.v1.Message last_message = 4;
        // where 'relevant' means "relevant to UI updates". For example,
        // when a user has read the latest message.
        PointerUpdate pointer = 5;
        message PointerUpdate {
            common.v1.UserId member = 1;
            messaging.v1.Pointer pointer = 2;
        }
        // IsTyping indicates whether or not someone is typing in the group.
        messaging.v1.IsTyping is_typing = 6;
    }
    message MemberUpdate {
        oneof kind {
            Refresh refresh = 1;
            // May want to add Joined and Removed events.
            // However, these may make more sense as a message, rather than
            // an out of band event.
        }
        message Refresh {
            repeated Member members = 1 ;
        }
    }
}
message GetChatsRequest {
    common.v1.QueryOptions query_options = 1;
    common.v1.Auth auth = 2;
}
message GetChatsResponse {
    Result result = 1;
    enum Result {
        OK = 0;
    }
    repeated Metadata chats = 2 ;
}
message GetChatRequest {
    oneof identifier {
        common.v1.ChatId chat_id = 1;
        uint64 room_number = 2;
    }
    // Auth is an optional field that authenticates the call, which
    // can be used to fill out extra information in the Metadata.
    common.v1.Auth auth = 10;
}
message GetChatResponse {
    Result result = 1;
    enum Result {
        OK        = 0;
        NOT_FOUND = 1;
    }
    // Metadata is the chat metadata, if result == OK.
    //
    // The contents of the metadata may change whether or not the
    // call was authenticated.
    Metadata metadata = 2;
    // Members contains the chat members, if result == OK.
    repeated Member members = 3;
}
message StartChatRequest {
    oneof parameters {
        StartTwoWayChatParameters two_way_chat = 1;
        StartGroupChatParameters group_chat = 2;
    }
    // StartTwoWayChatParameters contains the parameters required to start
    // or recover a two way chat between the caller and the specified 'other_user'.
    //
    // The 'other_user' is currently the 'tip_address', normally retrieved from
    // user.Identity.GetTwitterUser(username).
    message StartTwoWayChatParameters {
        // The account id of the user the caller wishes to chat with.
        common.v1.UserId other_user_id = 1;
        // The intent_id of the payment that initiated the chat/friendship.
        //
        // This field is optional. It is used as an optimization when the server has not
        // yet observed the establishment of a friendship. In this case, the server will
        // use the provided intent_id to verify the friendship.
        //
        // This is most likely to occur when initiating a chat with a user for the first
        // time.
        // common.v1.IntentId intent_id = 2;
    }
    message StartGroupChatParameters {
        // A set of users (not including self) to initially set in the group chat.
        repeated common.v1.UserId users = 1 ;
        // Optional title to set for the group.
        string title = 2;
        // TODO: Initial cost/price of chat(?)
    }
    common.v1.Auth auth = 10;
}
message StartChatResponse {
    Result result = 1;
    enum Result {
        OK = 0;
        // DENIED indicates the caller is not allowed to start/join the chat.
        DENIED = 1;
        // USER_NOT_FOUND indicates that (one of) the target user's was not found.
        USER_NOT_FOUND = 2;
    }
    // The chat to use if the RPC was successful.
    Metadata chat = 2;
}
message JoinChatRequest {
    oneof identifier {
        common.v1.ChatId chat_id = 1;
        uint64 room_id = 2;
    }
    // TODO: Payment information (if required)
    common.v1.Auth auth = 10;
}
message JoinChatResponse {
    Result result = 1;
    enum Result {
        OK = 0;
        DENIED = 1;
    }
    // The chat metadata, if join was successful.
    Metadata metadata = 2;
    // The members of the chat, if join was successful.
    repeated Member members = 3;
}
message LeaveChatRequest {
    common.v1.ChatId chat_id = 1;
    common.v1.Auth auth = 2;
}
message LeaveChatResponse {
    Result result = 1;
    enum Result {
        OK = 0;
    }
}
message SetMuteStateRequest {
    common.v1.ChatId chat_id = 1;
    bool is_muted = 2;
    common.v1.Auth auth = 3;
}
message SetMuteStateResponse {
    Result result = 1;
    enum Result {
        OK             = 0;
        DENIED         = 1;
        CANT_MUTE      = 2;
    }
}
message Metadata {
    common.v1.ChatId chat_id = 1;
    // The type of chat
    ChatType type = 2 ;
    enum ChatType {
        UNKNOWN = 0;
        TWO_WAY = 1;
        GROUP   = 2;
    }
    // The chat title, which is _only_ set by server if an explicit title
    // was set. Otherwise, clients should fill in an appropriate chat title.
    string title = 3 ;
    // If non-zero, the room number associated with the chat.
    uint64 room_number = 4;
    // Whether or not the chat is muted (from the perspective of the caller).
    bool is_muted = 5;
    // Whether or not the chat is mutable (from the persective of the caller).
    bool muteable = 6;
    // Number of (estimated) unread message (from the perspective of the caller).
    uint32 num_unread = 7;
}
message Member {
    common.v1.UserId user_id = 1;
    // The chat member's identity/profile information.
    //
    // It is a light weight version of the users full profile, which
    // can be retrieved from the Profile service.
    MemberIdentity identity = 2;
    // Chat message state for this member.
    //
    // If set, the list may contain DELIVERED and READ pointers. SENT pointers
    // are only shared between the sender and server, to indicate persistence.
    //
    // The server may wish to omit all pointers in various types of group chats
    // or as relief valves.
    repeated messaging.v1.Pointer pointers = 3 ;
    // If the member is the caller (where applicable), will be set to true.
    bool is_self = 4;
    // NOTE: We may switch to 'roles' in the future.
    bool is_host = 5;
}
message MemberIdentity {
    // If present, the display name of the user.
    string display_name = 1 ;
    // If present, the URL of the users profile pic.
    string profile_pic_url = 2 ;
}
